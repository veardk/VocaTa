<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocaTa AIå®æ—¶è¯­éŸ³å¯¹è¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.2em;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .status-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .connection-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .status-indicator.connected {
            background: #d4edda;
            color: #155724;
        }

        .status-indicator.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-indicator.listening {
            background: #d1ecf1;
            color: #0c5460;
            animation: pulse 2s infinite;
        }

        .status-indicator.speaking {
            background: #fff3cd;
            color: #856404;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .voice-controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .voice-visualizer {
            height: 80px;
            background: #f1f3f4;
            border-radius: 10px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .volume-bars {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 60px;
        }

        .volume-bar {
            width: 4px;
            background: #667eea;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .settings-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .setting-group input, .setting-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .range-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-group input[type="range"] {
            flex: 1;
        }

        .range-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .chat-log {
            height: 300px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            scroll-behavior: smooth;
        }

        .chat-message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 10px;
            animation: fadeIn 0.5s ease;
        }

        .chat-message.user {
            background: #e3f2fd;
            margin-left: 20%;
            border-bottom-right-radius: 5px;
        }

        .chat-message.ai {
            background: #f3e5f5;
            margin-right: 20%;
            border-bottom-left-radius: 5px;
        }

        .chat-message.system {
            background: #f5f5f5;
            text-align: center;
            font-style: italic;
            color: #666;
        }

        .message-time {
            font-size: 0.8em;
            color: #999;
            margin-bottom: 5px;
        }

        .message-content {
            line-height: 1.4;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .audio-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– VocaTa AIå®æ—¶è¯­éŸ³å¯¹è¯</h1>
            <p>è¿›å…¥é¡µé¢åè‡ªåŠ¨å¼€å§‹è¯­éŸ³ç›‘å¬ï¼Œè¯´è¯å³å¯ä¸AIè§’è‰²è¿›è¡Œå®æ—¶å¯¹è¯</p>
        </div>

        <div class="status-panel">
            <div class="connection-status">
                <div>
                    <span class="status-indicator disconnected" id="connectionStatus">WebSocketæœªè¿æ¥</span>
                    <span class="status-indicator" id="voiceStatus" style="display: none;">å¾…æœºä¸­</span>
                </div>
                <div class="audio-controls">
                    <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">è¿æ¥</button>
                    <button class="btn btn-secondary" id="clearBtn" onclick="clearChat()">æ¸…ç©ºå¯¹è¯</button>
                </div>
            </div>
        </div>

        <div class="voice-visualizer">
            <div class="volume-bars" id="volumeBars">
                <!-- åŠ¨æ€ç”ŸæˆéŸ³é‡æ¡ -->
            </div>
        </div>

        <div class="settings-panel">
            <h3 style="margin-bottom: 15px; color: #667eea;">è¯­éŸ³è®¾ç½®</h3>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div class="setting-group">
                    <label>è¯­éŸ³æ•æ„Ÿåº¦</label>
                    <div class="range-group">
                        <input type="range" id="sensitivity" min="0.01" max="0.5" step="0.01" value="0.1">
                        <span class="range-value" id="sensitivityValue">0.1</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label>é™éŸ³æ£€æµ‹æ—¶é•¿(ms)</label>
                    <div class="range-group">
                        <input type="range" id="silenceDelay" min="500" max="3000" step="100" value="1500">
                        <span class="range-value" id="silenceDelayValue">1500</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label>å¯¹è¯ID</label>
                    <input type="text" id="conversationId" value="123e4567-e89b-12d3-a456-426614174000">
                </div>

                <div class="setting-group">
                    <label>ç”¨æˆ·ID</label>
                    <input type="text" id="userId" value="1">
                </div>
            </div>
        </div>

        <div class="chat-log" id="chatLog">
            <div class="chat-message system">
                <div class="message-time" id="systemTime"></div>
                <div class="message-content">ç³»ç»Ÿå°±ç»ªï¼Œç‚¹å‡»"è¿æ¥"å¼€å§‹å®æ—¶è¯­éŸ³å¯¹è¯</div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let ws = null;
        let mediaRecorder = null;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let isConnected = false;
        let isListening = false;
        let isSpeaking = false;
        let silenceTimer = null;
        let audioChunks = [];
        let volumeBars = [];

        // VAD (Voice Activity Detection) é…ç½®
        let vadConfig = {
            sensitivity: 0.1,      // è¯­éŸ³æ£€æµ‹æ•æ„Ÿåº¦
            silenceDelay: 1500,    // é™éŸ³å¤šä¹…åå‘é€éŸ³é¢‘ (ms)
            minSpeakingTime: 300,  // æœ€å°‘è¯´è¯æ—¶é—´ (ms)
            volumeThreshold: 0.01  // éŸ³é‡é˜ˆå€¼
        };

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeVolumeVisualizer();
            updateSystemTime();
            initializeSettings();

            // é¡µé¢åŠ è½½å®Œæˆåæç¤ºç”¨æˆ·
            addMessage('system', 'é¡µé¢å·²åŠ è½½å®Œæˆï¼Œè¯·å…è®¸éº¦å…‹é£æƒé™åç‚¹å‡»è¿æ¥å¼€å§‹å¯¹è¯');
        });

        // åˆå§‹åŒ–éŸ³é‡å¯è§†åŒ–
        function initializeVolumeVisualizer() {
            const volumeBarsContainer = document.getElementById('volumeBars');
            volumeBarsContainer.innerHTML = '';

            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'volume-bar';
                bar.style.height = '5px';
                volumeBarsContainer.appendChild(bar);
                volumeBars.push(bar);
            }
        }

        // åˆå§‹åŒ–è®¾ç½®æ§ä»¶
        function initializeSettings() {
            const sensitivity = document.getElementById('sensitivity');
            const silenceDelay = document.getElementById('silenceDelay');

            sensitivity.addEventListener('input', function() {
                vadConfig.sensitivity = parseFloat(this.value);
                document.getElementById('sensitivityValue').textContent = this.value;
            });

            silenceDelay.addEventListener('input', function() {
                vadConfig.silenceDelay = parseInt(this.value);
                document.getElementById('silenceDelayValue').textContent = this.value;
            });
        }

        // åˆ‡æ¢è¿æ¥çŠ¶æ€
        async function toggleConnection() {
            if (!isConnected) {
                await startVoiceChat();
            } else {
                stopVoiceChat();
            }
        }

        // å¼€å§‹è¯­éŸ³èŠå¤©
        async function startVoiceChat() {
            try {
                // 1. è·å–éº¦å…‹é£æƒé™
                addMessage('system', 'æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...');
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });

                // 2. å»ºç«‹WebSocketè¿æ¥
                await connectWebSocket();

                // 3. åˆå§‹åŒ–éŸ³é¢‘å¤„ç†
                await initializeAudioProcessing(stream);

                // 4. å¼€å§‹è¯­éŸ³ç›‘å¬
                startVoiceActivityDetection();

                updateConnectionStatus(true);
                addMessage('system', 'âœ… å®æ—¶è¯­éŸ³å¯¹è¯å·²å¼€å¯ï¼å¼€å§‹è¯´è¯å³å¯ä¸AIå¯¹è¯');

            } catch (error) {
                console.error('å¯åŠ¨è¯­éŸ³èŠå¤©å¤±è´¥:', error);
                addMessage('system', `âŒ å¯åŠ¨å¤±è´¥: ${error.message}`);
                updateConnectionStatus(false);
            }
        }

        // åœæ­¢è¯­éŸ³èŠå¤©
        function stopVoiceChat() {
            // æ¸…ç†éŸ³é¢‘èµ„æº
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            if (microphone) {
                microphone.getTracks().forEach(track => track.stop());
                microphone = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            // å…³é—­WebSocketè¿æ¥
            if (ws) {
                ws.close();
                ws = null;
            }

            // æ¸…ç†å®šæ—¶å™¨
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }

            updateConnectionStatus(false);
            updateVoiceStatus('idle');
            addMessage('system', 'è¯­éŸ³å¯¹è¯å·²åœæ­¢');
        }

        // å»ºç«‹WebSocketè¿æ¥
        function connectWebSocket() {
            return new Promise((resolve, reject) => {
                const conversationId = document.getElementById('conversationId').value;
                const userId = document.getElementById('userId').value;
                const wsUrl = `ws://localhost:9009/ws/chat/${conversationId}?userId=${userId}`;

                ws = new WebSocket(wsUrl);

                ws.onopen = function() {
                    console.log('WebSocketè¿æ¥å·²å»ºç«‹');
                    resolve();
                };

                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (e) {
                        console.error('è§£æWebSocketæ¶ˆæ¯å¤±è´¥:', e);
                    }
                };

                ws.onclose = function(event) {
                    console.log('WebSocketè¿æ¥å·²å…³é—­:', event.code, event.reason);
                    if (isConnected) {
                        addMessage('system', `è¿æ¥å·²æ–­å¼€: ${event.reason || 'æœªçŸ¥åŸå› '}`);
                        stopVoiceChat();
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocketé”™è¯¯:', error);
                    reject(new Error('WebSocketè¿æ¥å¤±è´¥'));
                };

                // 10ç§’è¶…æ—¶
                setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        reject(new Error('è¿æ¥è¶…æ—¶'));
                    }
                }, 10000);
            });
        }

        // åˆå§‹åŒ–éŸ³é¢‘å¤„ç†
        async function initializeAudioProcessing(stream) {
            microphone = stream;

            // åˆ›å»ºAudioContext
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);

            // åˆ›å»ºåˆ†æå™¨ç”¨äºéŸ³é‡æ£€æµ‹
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;
            source.connect(analyser);

            // åˆ›å»ºMediaRecorderç”¨äºå½•éŸ³
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus'
            });

            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = function() {
                if (audioChunks.length > 0) {
                    processAudioChunks();
                }
            };
        }

        // å¼€å§‹è¯­éŸ³æ´»åŠ¨æ£€æµ‹
        function startVoiceActivityDetection() {
            isListening = true;
            updateVoiceStatus('listening');
            detectVoiceActivity();
        }

        // æ£€æµ‹è¯­éŸ³æ´»åŠ¨
        function detectVoiceActivity() {
            if (!isListening || !analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            // è®¡ç®—éŸ³é‡
            const volume = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length / 255;

            // æ›´æ–°å¯è§†åŒ–
            updateVolumeVisualization(volume);

            // æ£€æµ‹è¯­éŸ³æ´»åŠ¨
            if (volume > vadConfig.sensitivity && !isSpeaking) {
                startSpeaking();
            } else if (volume <= vadConfig.volumeThreshold && isSpeaking) {
                // å¼€å§‹é™éŸ³è®¡æ—¶
                if (!silenceTimer) {
                    silenceTimer = setTimeout(() => {
                        stopSpeaking();
                    }, vadConfig.silenceDelay);
                }
            } else if (volume > vadConfig.volumeThreshold && silenceTimer) {
                // å–æ¶ˆé™éŸ³è®¡æ—¶ï¼ˆç»§ç»­è¯´è¯ï¼‰
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }

            // ç»§ç»­ç›‘å¬
            if (isListening) {
                requestAnimationFrame(detectVoiceActivity);
            }
        }

        // å¼€å§‹è¯´è¯
        function startSpeaking() {
            if (isSpeaking) return;

            isSpeaking = true;
            audioChunks = [];
            updateVoiceStatus('speaking');
            addMessage('system', 'ğŸ¤ æ£€æµ‹åˆ°è¯­éŸ³ï¼Œå¼€å§‹å½•éŸ³...');

            // æ¸…é™¤é™éŸ³è®¡æ—¶å™¨
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }

            // å¼€å§‹å½•éŸ³
            if (mediaRecorder && mediaRecorder.state === 'inactive') {
                mediaRecorder.start(100); // æ¯100msæ”¶é›†ä¸€æ¬¡æ•°æ®
            }
        }

        // åœæ­¢è¯´è¯
        function stopSpeaking() {
            if (!isSpeaking) return;

            isSpeaking = false;
            updateVoiceStatus('processing');
            addMessage('system', 'ğŸ”„ è¯­éŸ³å½•åˆ¶å®Œæˆï¼Œæ­£åœ¨å¤„ç†...');

            // æ¸…é™¤é™éŸ³è®¡æ—¶å™¨
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }

            // åœæ­¢å½•éŸ³
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        // å¤„ç†éŸ³é¢‘æ•°æ®
        function processAudioChunks() {
            if (audioChunks.length === 0) {
                updateVoiceStatus('listening');
                return;
            }

            const audioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });

            // å°†éŸ³é¢‘è½¬æ¢ä¸ºArrayBufferå¹¶å‘é€åˆ°WebSocket
            audioBlob.arrayBuffer().then(buffer => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // å…ˆå‘é€éŸ³é¢‘å¼€å§‹ä¿¡å·
                    ws.send(JSON.stringify({
                        type: 'audio_start'
                    }));

                    // å‘é€éŸ³é¢‘æ•°æ®
                    ws.send(buffer);

                    // å‘é€éŸ³é¢‘ç»“æŸä¿¡å·
                    ws.send(JSON.stringify({
                        type: 'audio_end'
                    }));

                    addMessage('user', 'ğŸ¤ [è¯­éŸ³æ¶ˆæ¯å·²å‘é€]');
                } else {
                    addMessage('system', 'âŒ WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€éŸ³é¢‘');
                }

                // æ¸…ç©ºéŸ³é¢‘ç¼“å­˜
                audioChunks = [];
                updateVoiceStatus('listening');
            });
        }

        // å¤„ç†WebSocketæ¶ˆæ¯
        function handleWebSocketMessage(data) {
            console.log('æ”¶åˆ°WebSocketæ¶ˆæ¯:', data);

            switch (data.type) {
                case 'status':
                    addMessage('system', data.message);
                    break;

                case 'stt_result':
                    if (data.text && data.text.trim()) {
                        addMessage('user', `ğŸ’¬ ${data.text}`);
                    }
                    break;

                case 'llm_response':
                    if (data.text && data.text.trim()) {
                        addMessage('ai', `ğŸ¤– ${data.text}`);
                    }
                    break;

                case 'audio_data':
                    if (data.audioData) {
                        playAudioResponse(data.audioData);
                    }
                    break;

                case 'error':
                    addMessage('system', `âŒ é”™è¯¯: ${data.error}`);
                    break;

                case 'pong':
                    // å¿ƒè·³å“åº”ï¼Œä¸éœ€è¦å¤„ç†
                    break;

                default:
                    console.log('æœªçŸ¥æ¶ˆæ¯ç±»å‹:', data);
            }
        }

        // æ’­æ”¾AIè¯­éŸ³å›å¤
        function playAudioResponse(audioBase64) {
            try {
                const audioBytes = atob(audioBase64);
                const audioArray = new Uint8Array(audioBytes.length);
                for (let i = 0; i < audioBytes.length; i++) {
                    audioArray[i] = audioBytes.charCodeAt(i);
                }

                const audioBlob = new Blob([audioArray], { type: 'audio/mp3' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);

                audio.onloadeddata = () => {
                    addMessage('system', 'ğŸ”Š æ­£åœ¨æ’­æ”¾AIè¯­éŸ³å›å¤...');
                };

                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    addMessage('system', 'âœ… AIè¯­éŸ³å›å¤æ’­æ”¾å®Œæˆ');
                };

                audio.onerror = (e) => {
                    console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e);
                    addMessage('system', 'âŒ AIè¯­éŸ³æ’­æ”¾å¤±è´¥');
                };

                audio.play();

            } catch (error) {
                console.error('å¤„ç†AIè¯­éŸ³å¤±è´¥:', error);
                addMessage('system', 'âŒ AIè¯­éŸ³å¤„ç†å¤±è´¥');
            }
        }

        // æ›´æ–°éŸ³é‡å¯è§†åŒ–
        function updateVolumeVisualization(volume) {
            volumeBars.forEach((bar, index) => {
                const height = Math.max(5, volume * 60 * (1 - Math.abs(index - 10) * 0.1));
                bar.style.height = height + 'px';
                bar.style.opacity = volume > vadConfig.sensitivity ? '1' : '0.3';
            });
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');

            if (connected) {
                statusElement.textContent = 'WebSocketå·²è¿æ¥';
                statusElement.className = 'status-indicator connected';
                connectBtn.textContent = 'æ–­å¼€';
                connectBtn.className = 'btn btn-secondary';
            } else {
                statusElement.textContent = 'WebSocketæœªè¿æ¥';
                statusElement.className = 'status-indicator disconnected';
                connectBtn.textContent = 'è¿æ¥';
                connectBtn.className = 'btn btn-primary';
            }
        }

        // æ›´æ–°è¯­éŸ³çŠ¶æ€æ˜¾ç¤º
        function updateVoiceStatus(status) {
            const voiceStatusElement = document.getElementById('voiceStatus');

            if (!isConnected) {
                voiceStatusElement.style.display = 'none';
                return;
            }

            voiceStatusElement.style.display = 'inline-flex';

            switch (status) {
                case 'listening':
                    voiceStatusElement.textContent = 'ğŸ‘‚ ç›‘å¬ä¸­...';
                    voiceStatusElement.className = 'status-indicator listening';
                    break;
                case 'speaking':
                    voiceStatusElement.textContent = 'ğŸ¤ å½•éŸ³ä¸­...';
                    voiceStatusElement.className = 'status-indicator speaking';
                    break;
                case 'processing':
                    voiceStatusElement.textContent = 'ğŸ”„ å¤„ç†ä¸­...';
                    voiceStatusElement.className = 'status-indicator';
                    break;
                case 'idle':
                default:
                    voiceStatusElement.textContent = 'ğŸ’¤ å¾…æœºä¸­';
                    voiceStatusElement.className = 'status-indicator';
                    break;
            }
        }

        // æ·»åŠ èŠå¤©æ¶ˆæ¯
        function addMessage(type, content) {
            const chatLog = document.getElementById('chatLog');
            const message = document.createElement('div');
            message.className = `chat-message ${type}`;

            const time = new Date().toLocaleTimeString();
            message.innerHTML = `
                <div class="message-time">${time}</div>
                <div class="message-content">${content}</div>
            `;

            chatLog.appendChild(message);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        // æ¸…ç©ºèŠå¤©è®°å½•
        function clearChat() {
            const chatLog = document.getElementById('chatLog');
            chatLog.innerHTML = '';
            updateSystemTime();
            addMessage('system', 'èŠå¤©è®°å½•å·²æ¸…ç©º');
        }

        // æ›´æ–°ç³»ç»Ÿæ—¶é—´
        function updateSystemTime() {
            const systemTimeElement = document.getElementById('systemTime');
            if (systemTimeElement) {
                systemTimeElement.textContent = new Date().toLocaleTimeString();
            }
        }

        // é¡µé¢å…³é—­æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', function() {
            stopVoiceChat();
        });

        // å®šæœŸå¿ƒè·³æ£€æµ‹
        setInterval(function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping' }));
            }
        }, 30000);
    </script>
</body>
</html>